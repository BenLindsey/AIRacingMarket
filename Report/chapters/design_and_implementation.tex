\section{System Architecture}

Our first step, after reading the description of our project, was to decide what kind of application or system would be best suited to tackle our requirements. The first thing that we gleaned from the specification was that some form of persistent storage would be required. For example, the user submitted scripts must be stored so that they can later be raced against new scripts and data used to rank the scripts must be recorded so that a leaderboard can be shown. It was also mentioned in our project's specification that we should use the Unity game engine for the physics simulation and visualisation of our vehicle races. These two requirements gave us a solid starting point for designing our system. Our first thought was to develop a stand alone Unity application to run on any desktop machine. This option would have required one machine to act as a server and manage the centralised data while the other machines communicate with it using networking code inside of Unity. It would also have meant we'd need to build a full user interface for uploading, editing and managing scripts inside of Unity. The more we thought about this the more we realised that these tasks would be a massive undertaking and highly difficult to achive in the time frame, due to our group's limited knowledge of Unity.

Once we began thinking about alternatives an obvious solution sprang to mind. A huge benifit of Unity is that it is highly portable and can be run on many different platforms. One of these platforms is the Unity Web Player, a browser plug-in that allows Unity applications to be run inside all modern web browsers. If we used the web player we would could pull all of the things that are difficult to do in Unity outside of the Unity application and into the web browser. Thus turning the task of creating an easy to use interface for uploading scripts into a web design problem, a domain that is a lot better suited to solve user interface tasks such as this. The Unity application is then only needed for running and visualising the races. Unity also provides features for communication with the web browser, in both directions, when running in the web player, making passing data to the Unity application at runtime easy. This design also reduces the complexity of the networking problems as now one machine can run a web-server and database, using standard web technologies, while client machines simply run a web browser, containing the Unity Web Player, and communicate with the server using standard web protocols.

\subsection{Component Diagram}

\tikzset{%
  block/.style    = {draw, thick, rectangle, minimum height = 3em, rounded corners,
    minimum width = 3.5em, align=center},
  sum/.style      = {draw, circle, node distance = 2cm}, % Adder
  %input/.style    = {coordinate},
  db/.style  = {draw, cylinder, shape border rotate=90, aspect=0.25},
  interface/.style    = {draw, thick, rectangle, 
    minimum width = 4em, align=center},
}

\begin{center}
\begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
	% Blocks of FRONT END:
	\draw
		node at (1, -1.5) [block] (unity) {Unity}
		node at (11, -1.5) [block] (browser) {Browser}
		%node [sum, right of=input1] (suma1) {Unity}
	;
    	% Joining FRONT END:
	%\draw[->](input1) -- node {$X(Z)$}(suma1);
	
	% Blocks of MIDDLE
	\draw
		node at (5.5,-4) [block, name=rest] {REST API}
	;

        % Blocks of BACK END
	\draw
	        node [block, below of=unity, below=2.5cm, name=express] {Express\\Router}
	        node [block, right of=express, right=0cm, name=passport] {Passport \\ Auth.}
	        node [db, below of=passport, below=0cm, name=mongo] {MongoDB}
	        node [interface, above of=mongo, above=-1cm, name=monk] {Monk Adapter}
	        node [block, right of=passport, right=0cm, name=routes] {Routes}
	        node [block, right of=routes, right=0cm, name=views] {Views}
	;
	% Joining BACK END
	\draw[->] (express) -- node {} (passport);
	\draw[->] (rest) -| node {} (express);
	\draw[->] ($(browser.south) + (-0.2, 0)$) |- node {} (rest);
	\draw[-, dotted] (passport) -- node[below right] {} (monk);
	\draw[-] (monk) -- node {} (mongo);
	\draw[->] (passport) -- node {} (routes);
	\draw[->] (routes) -- node {} (views);
	\draw[-, dotted] (routes) |- node {} (monk);
	\draw[->] (views) -| node {} ($(browser.south) + (0.2, 0)$);
        
	% Boxing
	%\draw [color=gray,thick, dotted] ($(passport.north west)+(-0.2,0.2)$) rectangle ($(monk.south east)+(0.2,-0.2)$);
        %\node at (passport) [above=3mm, right=0mm] {\small If private};
        
	\draw [color=gray,thick](-0.5,-3) rectangle (12.5,0);
	\node at (-0.5,0) [above=5mm, right=0mm] {\textsc{Front-End}};
	\draw [color=gray,thick](-0.5,-10.5) rectangle (12.5,-5);
	\node at (-0.5,-10.5) [below=5mm, right=0mm] {\textsc{Back-End}};
\end{tikzpicture}
\end{center}

\section{Back-end}

The design of our back-end is focused around a simple REST API. The implementation primarily involves NodeJS and supporting libraries:
Our back end system is designed to provide two different services. ??
First is to provide the website for our product... ??
Second is a REST API for manging the getting, submitting and updating of user scripts ?? 

Tech used:
\begin{itemize}
\item Node.js
	\begin{itemize}
		\item Mocha \& Zombie.js (described later in evaluation testing section though)
		\item Passport (passport-local)
		\item Monk \& Mongoose
	\end{itemize}
\item MongoDB
\end{itemize}

\subsection{Examples of the REST API}
\begin{tabular}{| l | l | l | l |}\hline
Route & Request &  Response & Explanation\\\hline\hline
/script & GET & View & Show the create new script page\\\hline
/script & POST & None & Store a new script to the server\\\hline
/script/DrEvil & GET & String & Get the code for script DrEvil\\\hline
/edit/DrEvil & GET & View & Show the live edit script page\\\hline
/tournament & GET & View & Show the next tournament match\\\hline
/tournament & POST & View & Store the match result and show the next \\\hline
\end{tabular}

\subsection{Risks}
Anticipation \& Mitigation

\subsection{Challenges}
Solutions

\section{Browser Front-End {\color{red} TOM}}

For the browser front-end, i.e. website, we used three technologies : 
\\

\noindent
{\bf Jade}  \hspace*{2mm} 
As explained above, we chose to use the Node.js platform, and we next had to chose a template engine for it's web template system. We chose to use Node's default engine, Jade, which is written in JavaScript and specifically a templating language for HTML. It simplifies writing web pages as it is less verbose than HTML, and allows  template inheritance alongside other dynamic constructs such as conditionals and loops. Compared to other engines such as Swig and Hamljs, which have similar feature sets, Jade has had reported sluggish benchmarking performance \footnote{http://paularmstrong.github.io/node-templates/benchmarks.html} (obviously some benchmarks can't be treated as gospel). However, performance was not a concern for us; templating engines are very rarely a system bottleneck, and the decision to use Jade was founded upon it's usability and readability.
\\

\noindent
{\bf Bootstrap}  \hspace*{2mm} 
Given our limited experience using Jade/HTML and CSS, alongside our negligible artistic talent, we opted to use Twitter's Bootstrap to design our website. Bootstrap makes web design a breeze by providing the HTML and CSS templates for well-designed web components, including forms, buttons, navigation bars, JavaScript extensions and more. In particular, we used the Sandstone \footnote{http://bootswatch.com/sandstone/} template from Bootswatch (released under MIT license). Although this may not give users with a particularly unique experience, it means providing users with a familiar experience that would allow them to utilise preconceived assumptions on how the website can be navigated - avoiding the need to explain the website explicitly.
\\

\noindent
{\bf Ace} \hspace*{2mm} 
Apart from the most cavalier advocates of text editors, programmers shudder at the idea of coding in a plain text area. To simplify the process of reading, writing and submitting scripts, we chose to use a web-based code editor. There are few open-source editors that can rival the performance, features and simplicity of Ace (a standalone editor written in JavaScript). Ace is actively developed for use in the online Cloud9 IDE, yet can be embedded in any web page given its BSD license. By using Ace, users have JavaScript syntax highlighting, syntax error checking, searching/replace, automatic indentation etc. Not only does this improve the productivity of a user, which is important given the time pressures which may be faced if a queue forms at the G-Research careers fair stand; but it provides immediate feedback for those unfamiliar with JavaScript syntax, which may be the majority of users, reducing the likelihood of submitting broken scripts.
\\

\subsection{Design}
Website layout / key design features 
\begin{itemize}
\item Responsive edit screen
\item Anonymous/logged in submit screens
\item Admin accessible features
\end{itemize}

\subsection{Risks}
Anticipation \& Mitigation

\subsection{Challenges}
Solutions

\section{Unity Application}
No external tech used except for a few of Unity's basic script assets, e.g. smooth follow cam.

Main design points:
Designing the Script API
Managing and recording race data e.g. checkpoints, hud
Comunication with browser i.e. starting race, where scripts are exectued, how many calls per frame

Unity applications are based around a system of scenes that can be switched between at runtime. We used this in our application to have a seperate scene for each racetrack we had built. As, in our case, each time the application is loaded only 

\subsection{Risks}
Spending ages on 

Anticipation \& Mitigation

\subsection{Challenges}
Designing the script API

Initially we had a very simplistic system of controling and receving environment information from the car. 

steering and throttle control for control. Proximity sensors (ray casting) for position information. 

Solutions

\section{User Interface Design. TODO: Add some of "evaluation" section here? {\color{red} TOM}}
Aims:
\begin{itemize}
\item Easy to navigate (hence bootstrap for simple familiar website) 
\item 
\end{itemize}



\subsection{Justification}


\section{Harvesting Personal Data TODO}
One of the primary objectives of our project is the acquisition of personal data about potential employees. This includes information such as email address, university degree, etc. 
\subsection{Non-invasive authentication}
We don't want to scare users away to early...
Allow anonymous script posting..
\subsection{Risks}
We must avoid leaking personal data...
For example, when designing our leaderboard we had to bare in mind we didn't want to display user's emails to passing strangers...


